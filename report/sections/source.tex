\lstset{ %
language=Python,                % the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=none,                   % adds a frame around the code
tabsize=2,                      % sets default tabsize to 2 spaces
captionpos=b,                   % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
}


\newpage
\section{asmlex.py}
\lstinputlisting{../src/asmlex.py}


\newpage
\section{asmyacc.py}
\lstinputlisting{../src/asmyacc.py}

\newpage
\section{block\_optimise.py}
\begin{lstlisting}
""" 
File:         block_optimise.py
Course:       Compilerbouw 2011
Author:       Joris Stork, Lucas Swartsenburg, Jeroen Zuiddam


Description:
    Defines the various subclasses of block optimiser. Currently implemented:
        ConstantFold
        DeadCode
        CopyPropagation

"""


from cfg import BasicBlock
import re
import ir
from ir import Instr
import math
from peephole import Peephole, Peeper
from uic import copy_prop_targets, copy_prop_unsafe, assign_to
import logging


class BlockOptimiser(object):
    """ Parent class for the various block optimisations.  """


    def __init__(self, block = None, peephole_size = None):
        """ By default the peephole size is that of the basic block """

        self.block = block
        self.stats = {'dc':0,'cp':0,'cf':0}
        if not peephole_size:
            self.p_size = len(block)
        else:
            self.p_size = peephole_size


    def set_block(self, block):
        """ Optimiser can be re-assigned to a new block  """
        
        self.block = block


    def set_peephole_size(self, size):
        """ Optimiser can be tweaked with a new peephole size. """

        self.p_size = size


    def rename_temp_vars(self):
        """ Renames temporary variables until bb is in normal form."""
        pass

    
    def reg_within(self, subject, args):
        """ Returns true if the string is a substring of one of args[i] """
        found = False
        for arg in args:
            if isinstance(arg, str):
                m = re.search('\$\w*', arg)
                if m:
                    arg_reg = m.group(0)
                else: continue
                found = found | (arg_reg == subject)
        return found


    def find_constants(self, before = 0):
        """ 
        compiles a dict of (register,constant) pairs, with the constant
        corresponding to the last value in the given register before the
        ``before'' register 
        we can improve this function by keeping track of constants, e.g. after
        moves.
        
        """
        consts = {}
        for ins in self.peephole[0:before]:
            if isinstance(ins,Instr):
                if ins.instr == 'li':
                    consts[ins.args[0].expr] = ins.args[1]
        return consts


    def suboptimisation(self):
        """ Defined in subclass  """

        pass


    def optimise(self):
        """ If block assigned, runs sub-optimisation until exhausted. """

        changed = False
        if not self.block: 
            """ raise an exception here """
            return changed
        peeper = Peeper(self.block, self.p_size)
        optimised = False
        for peephole in peeper:
            self.peephole = peephole
            optimised = True
            while optimised:
                optimised = self.suboptimisation()
                changed = changed | optimised
        return changed



class ConstantFold(BlockOptimiser):
    """ Replaces arithmetic expression with only constants, with value """


    def addu(self, i, ins, opt, consts):
        """ 
        Replaces addu instruction with value. Though not guaranteed to replicate
        unsigned behaviour, should be ok for benchmarks (c.f. report)
        Note: We take into account that addu's might include compile-time
        immediate values, since we encountered that in the benchmark code. Addu
        seems to incorporate addiu functionality since no addiu's were found in
        the benchmark code.
        
        """    
        optimised = opt
        if ins.instr == 'addu':

            arg1_is_reg = isinstance(ins.args[1],ir.Register)
            arg2_is_reg = isinstance(ins.args[2],ir.Register)
            none_reg = (not arg1_is_reg) & (not arg2_is_reg)
            arg1_known_reg = False
            arg2_known_reg = False
            if arg1_is_reg:
                arg1_known_reg = (self.reg_within(ins.args[1].expr, consts))
            if arg2_is_reg:
                arg2_known_reg = (self.reg_within(ins.args[2].expr, consts))
            both_known_regs = arg1_known_reg & arg2_known_reg
            c1 = None
            c2 = None
            optimised_this_time = True

            if both_known_regs:
                c1 = consts[ins.args[1].expr]
                c2 = consts[ins.args[2].expr]
            elif none_reg:
                c1 = ins.args[1]
                c2 = ins.args[2]
            elif arg1_known_reg & (not arg2_is_reg):
                c1 = consts[ins.args[1].expr]
                c2 = ins.args[2]
            elif arg2_known_reg & (not arg1_is_reg):
                c1 = ins.args[1]
                c2 = consts[ins.args[2].expr]
            else:
                optimised_this_time = False

            if optimised_this_time:
                if isinstance(c1,str):
                    c1 = int(c1,0)
                if isinstance(c2,str):
                    c2 = int(c2,0)
                fold = c1 + c2 
                self.logger.debug(' being replaced... '+str(self.peephole[i]))
                self.peephole[i] = Instr('li',[ins.args[0], hex(fold)])
                self.logger.debug('new instruction: '+str(self.peephole[i]))
                consts[self.peephole[i].args[0].expr] = self.peephole[i].args[1]
                optimised = True
                self.logger.debug('constant folded')
                self.stats['cf'] += 1
        return optimised


    def suboptimisation(self):
        """ if 2+ compile time constants, tries constant folding """
        self.logger = logging.getLogger('ConstantFold')
        optimised = False
        for i, ins in enumerate(self.peephole):
            if isinstance(ins,Instr):
                consts = self.find_constants(i)
                if len(consts) > 1:
                    optimised = self.addu(i, ins, optimised, consts)
        return optimised



class CopyPropagation(BlockOptimiser):
    """ after copy, propagate original variable where copy unaltered """

    def propagate_from_move(self, i, ins, opt):
        """ if a move, substitutes subsequent uses of unaltered copy value """
        optimised = opt
        if ins.instr == 'move': 
            orig = ins.args[1]
            copy = ins.args[0] # nb: move not explicity defined for simplescalar
            for i2, ins2 in enumerate(self.peephole[i+1:len(self.peephole)]):
                if isinstance(ins2,Instr):
                    args = []
                    for arg in ins2.args:
                        if isinstance(arg,str) | isinstance(arg,int) :
                            args.append(arg)
                        else:
                            args.append(arg.expr)
                copy_in_args = self.reg_within(copy.expr, args)
                orig_in_args = self.reg_within(orig.expr, args)
                if not isinstance(ins2, Instr):
                    continue
                elif str(ins2.instr) not in copy_prop_targets:
                    unsafe = str(ins2.instr) in copy_prop_unsafe
                    if unsafe & (copy_in_args | orig_in_args):
                        return optimised
                    else: continue
                elif copy_in_args:
                    argsize = len(ins2.args)
                    if self.reg_within(copy.expr, args[1:argsize]):
                        one = args[1:argsize].index(copy.expr) + 1
                        msg = ' being replaced... '+str(self.peephole[i+1+i2])
                        self.logger.debug(msg)
                        ins2.args[one] = orig
                        if args[1:argsize].count(copy.expr) == 2:
                            two=args[one+1:argsize].index(copy.expr)+one+1
                            ins2.args[two] = orig
                        self.peephole[i+1+i2] = ins2
                        msg = 'new instruction: '+str(self.peephole[i+1+i2])
                        self.logger.debug(msg)
                        optimised = True
                        self.logger.debug('copy propagated')
                        self.stats['cp'] += 1

                    if(copy.expr==args[0])|(self.reg_within(orig.expr,args[0])):
                        return optimised
                else:
                    continue
        return optimised
                            

    def suboptimisation(self):
        """ 
        finds copies; then: if unaltered copy used later, substitute with
        original; else ignore
        
        """

        self.logger = logging.getLogger('CopyPropagation')
        optimised = False
        for i, ins in enumerate(self.peephole):
            if isinstance(ins,Instr):
                optimised = self.propagate_from_move(i, ins, optimised)
        return optimised



class DeadCode(BlockOptimiser):
    """ 
    Finds and removes instructions that assign a value that is then never used.  
    
    """


    def subscan(self, i, ins, opt, cand_reg_index):
        """ 
        Searches subsequent instructions, and: stops if candidate register is
        used; or removes the candidate instruction if register is overwritten.
        Note: the only instruction object without an args attribute is the nop
        instruction. Such instructions are ignored.

        """
        optimised = opt
        for i2, ins2 in enumerate(self.peephole[i+1:len(self.peephole)]):
            candidate_reg = ins.args[cand_reg_index]
            ins2_is_instruction = isinstance(ins,Instr)
            args = []
            if ins2_is_instruction:
                try:
                    for arg in ins2.args:
                        if isinstance(arg,str) | isinstance(arg,int) :
                            args.append(arg)
                        else:
                            args.append(arg.expr)
                except AttributeError:
                    continue
            if not ins2_is_instruction:
                continue
            elif not self.reg_within(candidate_reg.expr, args):
                continue
            elif str(ins2.instr) in assign_to:
                assigned_to_index = assign_to[str(ins2.instr)]
                pre_args = args[0:assigned_to_index]
                post_args = args[assigned_to_index+1:len(args)]
                if self.reg_within(candidate_reg.expr,pre_args+post_args):
                    return optimised
                else: 
                    self.logger.debug(' being removed... '+str(self.peephole[i]))
                    del self.peephole[i]
                    optimised = True
                    self.logger.debug('instruction removed')
                    self.stats['dc'] += 1
                    return optimised
            else: return optimised
        return optimised


    def suboptimisation(self):
        """   """
        
        optimised = False
        self.logger = logging.getLogger('DeadCode')
        candidate = None
        for i, ins in enumerate(self.peephole):
            if not isinstance(ins,Instr):
                continue
            elif str(ins.instr) in assign_to:
                cand_reg_index = assign_to[str(ins.instr)]
                optimised = self.subscan(i, ins, optimised, cand_reg_index)
        return optimised
\end{lstlisting}


\newpage
\section{block\_opt\_lab.py}
%\lstinputlisting{../src/block\_opt\_lab.py}
\begin{lstlisting}
""" 
File:         block_opt_lab.py
Course:       Compilerbouw 2011
Author:       Joris Stork, Lucas Swartsenburg, Jeroen Zuiddam


Description:
    Block optimisers not ready for prime-time.

"""

from cfg import BasicBlock
import ir
from ir import Instr
import math
from peephole import Peephole, Peeper
from uic import copy_prop_targets, copy_prop_unsafe, assign_to
import logging


class AlgebraicTransformations(BlockOptimiser):
    """ contains various algebraic transformation optimisations  """
    # Need to look for values of variables


    def divd_to_sra(self, i, ins, opt, consts):
        """ 
        shift-right arithmetic is faster than division... 
        Needs fixing: div.d only ever uses $fn (floating point) registers. li
        instructions (used to find constants) only use $n registers. Note that
        manual states that div instructions write to hi and lo registers,
        whereas benchmark code makes use of an fd register.
       
       """
        optimised = opt
        if ins.instr == 'div.d':
            if (ins.args[1].expr in consts) & (ins.args[2].expr in consts):
                n = math.log(consts[ins.args[2].expr], 2)
                if n % 1 == 0:
                    newins = Instr('sra', [ins.args[0], consts[ins.args[1].expr], n])
                    self.peephole[i] = newins
                    self.logger.info('algebraic transformed (div->sra)')
                    optimised = True
        return optimised


    def suboptimisation(self):
        """   """
        
        self.logger = logging.getLogger('AlgebraicTransformations')
        optimised = False
        for i, ins in enumerate(self.peephole):
            if isinstance(ins,Instr):
                consts = self.find_constants(i)
                #optimised=self.divd_to_sra(i, ins, optimised, consts)#cf shelf 
                #TODO: any other algebraic opts? (sla not available)
        return optimised



class CommonSubexpressions(BlockOptimiser):
    """ Block optimisation: duplicate subexpressions -> variables"""

    def suboptimisation(self):
        """ If duplicate subexpression found within peephole,  """

        optimised = False

        return optimised



class TempVarRename(BlockOptimiser):
    """   """

    def suboptimisation(self):
        """   """

        optimised = False

        return optimised



class ExchangeIndependentStatements(BlockOptimiser):
    """   """

    def suboptimisation(self):
        """   """

        optimised = False

        return optimised



class MachineDependentTransformations(BlockOptimiser):
    """   """

    def suboptimisation(self):
        """   """

        optimised = False

        return optimised
\end{lstlisting}
\newpage
\section{cfg.py}
\lstinputlisting{../src/cfg.py}

\newpage
\section{dataflow.py}
\lstinputlisting{../src/dataflow.py}

\newpage
\section{flat.py}
\lstinputlisting{../src/flat.py}

\newpage
\section{ir.py}
\lstinputlisting{../src/ir.py}

\newpage
\section{liveness.py}
\lstinputlisting{../src/liveness.py}

\newpage
\section{optimise.py}
\lstinputlisting{../src/optimise.py}

\newpage
\section{optimise\_tree.py}
%\lstinputlisting{../src/optimise_tree.py}
\begin{lstlisting}
import cfg
from ir import *


def optimise(graph):
    """
    Runs various optimisation schemes on the cfg
    """
    graph = remove_notused(graph)
    graph = flatten(graph)
    return graph

def remove_notused(graph):
    """
    All blocks that have no incoming edges are removed.
    Ofcourse the starting block is ignored, as well as
    the block that only contains a raw .end instruction.
    """
    for (i, block) in enumerate(graph.blocks):
        if i != 0 and len(graph.get_in_edges(block)) == 0:
            for instr in block.instructions:
                if type(instr) == Instr:
                    block.instrucions.remove(instr)
            if len(block.instructions) == 0:
                graph.remove_block(block)
            
                
    return graph

def flatten(graph):
    """
    If a block has only one incoming edge and the block on the other side of the edge
    has only one outgoing edge, the blocks can be joined into one.

    After this, jump optimalisation is needed.
    """
    clean = False
    while(not clean):
        clean = True
        length = len(graph.blocks)
        for i in xrange(length - 1):
            
            te = graph.get_in_edges(graph.blocks[i + 1])
            
            if len(te) == 1:
                et = graph.get_out_edges(te[0][0])
                if len(et) == 1:
                    een = graph.get_block(te[0][0])
                    twee = graph.blocks[i + 1]
                    td = graph.get_out_edges(twee)

                    een.instructions = een.instructions + twee.instructions
                    for (fr, to) in td:
                        graph.edges.append((een.name, to))

                    graph.remove_block(twee.name)
                    clean = False
                    break

    return graph


def main():
    c = cfg.main()
    c.cfg_to_diagram("cfg_org.png")
    c = optimise(c)
    c.cfg_to_diagram("cfg_new.png")
    return c
if __name__ == '__main__':
    main()
    pass
\end{lstlisting}
\newpage
\section{parse\_instr.py}
%\lstinputlisting{../src/parse_instr.py}
\begin{lstlisting}
from ir import *
import re
numreg = re.compile("^(\$[a-z]?)([0-9]+)$")
Creg = re.compile("^([0-9]+)\((\$[A-Za-z0-9]+)\)$")

def parse(flat):
    for ex in flat:
        if type(ex) == Instr:
            i = Instruction(ex)
            ex.gen = i.gen
            ex.need = i.need
            ex.c = i.c
            ex.label = i.label
            ex.ival = i.ival
    return flat

class Instruction(object):

    def __init__(self,ins):
        self.type = None
        self.ins = ins
        self.gen = []
        self.need = []
        self.c = None
        self.label = None
        self.ival = None
        self.parse(self.ins)

    def __str__(self):
        string  = ""
        if self.type:
            string += self.type
        if self.need:
            string += " Needs: " + str(self.need)
        if self.gen:
            string += ". Gens: " + str(self.gen)
            
        if self.label:
            string += ". Label: " + str(self.label)
        if self.ival:
            string += ". iVal: " + str(self.ival)
        if self.c:
            string += ". Offset: " + str(self.c)        
        return string
    
    def parse(self, ins):
        """
        Parses the instruction, to determine wich registers are used and set. 
        It also sets the offset used for loading an storing, used labels and
        used immidiate values.
        """
        if type(ins)!=Instr:
            raise Exception("You are parsing object that isn't a instruction")
        self.type = ins.instr
        if ins.instr in control_instructions:
            self.parse_control(ins)
        elif ins.instr in loadstore_instructions:
            self.parse_ls(ins)            
        elif ins.instr in intarithm_instructions :
            self.parse_int(ins)
        elif ins.instr in floatarithm_instructions:
            self.parse_float(ins)
        elif ins.instr in misc_instructions:
            self.parse_misc(ins)
        else:
            self.parse_unknown(ins)

    def parse_control(self,ins):
        """
        Parses the control type instructions.
        """    
        if ins.instr == 'j':
            if len(ins.args) == 1:
                self.label = [ins.args[0]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
        
        elif ins.instr == 'jal':
            self.gen = [Register("$31")] #Return address
            
        elif ins.instr == 'jr':
            if len(ins.args) == 1:
                self.need = [ins.args[0]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
            
        elif ins.instr == 'jalr':
            if len(ins.args) == 1:
                self.need = [ins.args[0]]
                self.gen = [Register("$31")] #Return address
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
            
        elif ins.instr == 'beq':
            if len(ins.args) == 3:
                self.need = [ins.args[0],ins.args[1]]
                self.label = Label(ins.args[2])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr) 
                           
        elif ins.instr == 'bne':
            if len(ins.args) == 3:
                self.need = [ins.args[0],ins.args[1]]
                self.label = Label(ins.args[2])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                
        elif ins.instr == 'blez':
            if len(ins.args) == 2:
                self.need = [ins.args[0]]
                self.label = Label(ins.args[1])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                
        elif ins.instr == 'bgtz':
            if len(ins.args) == 2:
                self.need = [ins.args[0]]
                self.label = Label(ins.args[1])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                
        elif ins.instr == 'bltz':
            if len(ins.args) == 2:
                self.need = [ins.args[0]]
                self.label = Label(ins.args[1])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                
        elif ins.instr == 'bgez':
            if len(ins.args) == 2:
                self.need = [ins.args[0]]
                self.label = Label(ins.args[1])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                
        elif ins.instr == 'bct':
            if len(ins.args) == 1:
                self.need = [Register("$fcc")]
                self.label = Label(ins.args[0])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                
        elif ins.instr == 'bcf':
            if len(ins.args) == 1:
                self.need = [Register("$fcc")]
                self.label = Label(ins.args[0])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                
        elif ins.instr == 'bc1f':
            if len(ins.args) == 1:
                self.need = [Register("$fcc")]
                self.label = Label(ins.args[0])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                
        elif ins.instr == 'bc1t':
            if len(ins.args) == 1:
                self.need = [Register("$fcc")]
                self.label = Label(ins.args[0])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)


    def parse_ls(self,ins):
        """
        Parses the load/store type instructions.
        """
        global Creg
        if ins.instr == 'lb':
            if len(ins.args) == 2:
                g = re.match(Creg, ins.args[1])
                if g:
                    self.c = g.group(1)
                    self.need = [Register(g.group(2))]
                else:
                    self.need = [ins.args[1]]
                self.gen = [ins.args[0]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr) 
                       
        elif ins.instr == 'lbu':
            if len(ins.args) == 2:
                g = re.match(Creg, ins.args[1])
                if g:
                    self.c = g.group(1)
                    self.need = [Register(g.group(2))]
                else:
                    self.need = [ins.args[1]]
                self.gen = [ins.args[0]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                 
        elif ins.instr == 'lh':
            if len(ins.args) == 2:
                g = re.match(Creg, ins.args[1])
                if g:
                    self.c = g.group(1)
                    self.need = [Register(g.group(2))]
                else:
                    self.need = [ins.args[1]]
                self.gen = [ins.args[0]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                
        elif ins.instr == 'lhu':
            if len(ins.args) == 2:
                g = re.match(Creg, ins.args[1])
                if g:
                    self.c = g.group(1)
                    self.need = [Register(g.group(2))]
                else:
                    self.need = [ins.args[1]] 
                self.gen = [ins.args[0]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                
        elif ins.instr == 'lw':
            if len(ins.args) == 2:
                g = re.match(Creg, ins.args[1])
                if g:
                    self.c = g.group(1)
                    self.need = [Register(g.group(2))]
                else:
                    self.need = [ins.args[1]] 
                self.gen = [ins.args[0]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                 
        elif ins.instr == 'dlw':
            if len(ins.args) == 2:
                g = re.match(Creg, ins.args[1])
                if g:
                    self.c = g.group(1)
                    self.need = [Register(g.group(2))]
                else:
                    self.need = [ins.args[1]]
                self.gen = self.double_reg(ins.args[0])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                 
        elif ins.instr == 'dmfc1':
            if len(ins.args) == 2:
                self.need = [ins.args[1]] 
                self.gen = self.double_reg(ins.args[0])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                
        elif ins.instr == 'l.s':
            if len(ins.args) == 2:
                self.need = [ins.args[1]]
                self.gen = [ins.args[0]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                
        elif ins.instr == 'l.d':
            if len(ins.args) == 2:
                self.need = [ins.args[1]]
                self.gen = self.double_reg(ins.args[0])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                
        elif ins.instr == 'sb':   
            if len(ins.args) == 2:
                g = re.match(Creg, ins.args[1])
                if g:
                    self.c = g.group(1)
                    self.need = [Register(g.group(2))]
                else:
                    self.need = [ins.args[1]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                  
        elif ins.instr == 'sbu':  
            if len(ins.args) == 2:
                g = re.match(Creg, ins.args[1])
                if g:
                    self.c = g.group(1)
                    self.need = [Register(g.group(2))]
                else:
                    self.need = [ins.args[1]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr) 
                                       
        elif ins.instr == 'sh':   
            if len(ins.args) == 2:
                g = re.match(Creg, ins.args[1])
                if g:
                    self.c = g.group(1)
                    self.need = [Register(g.group(2))]
                else:
                    self.need = [ins.args[1]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr) 
                                       
        elif ins.instr == 'shu':  
            if len(ins.args) == 2:
                g = re.match(Creg, ins.args[1])
                if g:
                    self.c = g.group(1)
                    self.need = [Register(g.group(2))]
                else:
                    self.need = [ins.args[1]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr) 
                                        
        elif ins.instr == 'sw':   
            if len(ins.args) == 2:
                g = re.match(Creg, ins.args[1])
                if g:
                    self.c = g.group(1)
                    self.need = [Register(g.group(2))]
                else:
                    self.need = [ins.args[1]] 
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr) 
                                      
        elif ins.instr == 'dsw':  
            if len(ins.args) == 2:
                g = re.match(Creg, ins.args[1])
                if g:
                    self.c = g.group(1)
                    self.need = [Register(g.group(2))]
                else:
                    self.need = [ins.args[1]] 
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr) 
                                     
        elif ins.instr == 'dsz':  
            if len(ins.args) == 1:
                g = re.match(Creg, ins.args[0])
                if g:
                    self.c = g.group(1)
                    self.need = [Register(g.group(2))]
                else:
                    self.need = [ins.args[0]]  
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr) 
                                    
        elif ins.instr == 's.s':  
            if len(ins.args) == 2:
                g = re.match(Creg, ins.args[1])
                if g:
                    self.c = g.group(1)
                    self.need = [Register(g.group(2))]
                else:
                    self.need = [ins.args[1]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr) 
                                         
        elif ins.instr == 's.d':  
            if len(ins.args) == 2:
                g = re.match(Creg, ins.args[1])
                if g:
                    self.c = g.group(1)
                    self.need = [Register(g.group(2))]
                else:
                    self.need = [ins.args[1]] 
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)   
                                      
        elif ins.instr == 'move':
            if len(ins.args) == 2:
                self.need = [ins.args[1]]
                self.gen = [ins.args[0]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)  
                         
        elif ins.instr == 'mov.d':
            if len(ins.args) == 2:
                self.need = self.double_reg(ins.args[1])
                self.gen = self.double_reg(ins.args[0])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)  
                         
        elif ins.instr == 'mov.s':
            if len(ins.args) == 2:
                self.need = [ins.args[1]]
                self.gen = [ins.args[0]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)  
                         
        elif ins.instr == 'li':
            if len(ins.args) == 2:
                self.gen = [ins.args[0]]
                self.ival = ins.args[1]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)           
            

    def parse_int(self,ins):
        """
        Parses the int type instructions.
        """
        if ins.instr == 'add':  
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                if self.is_reg(ins.args[2]):
                    self.need = [ins.args[1], ins.args[2]]
                else: 
                    self.need = [ins.args[1]]
                    self.ival = ins.args[2]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)   
                         
        elif ins.instr == 'addi': 
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1]]
                self.ival = ins.args[2]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)           
        
        elif ins.instr == 'addu': 
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                if self.is_reg(ins.args[2]):
                    self.need = [ins.args[1], ins.args[2]]
                else: 
                    self.need = [ins.args[1]]
                    self.ival = ins.args[2]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)           
        elif ins.instr == 'addiu':
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1]]
                self.ival = ins.args[2]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)   
                        
        elif ins.instr == 'sub': 
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                if self.is_reg(ins.args[2]):
                    self.need = [ins.args[1], ins.args[2]]
                else: 
                    self.need = [ins.args[1]]
                    self.ival = ins.args[2]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)  
                         
        elif ins.instr == 'subu': 
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                if self.is_reg(ins.args[2]):
                    self.need = [ins.args[1], ins.args[2]]
                else: 
                    self.need = [ins.args[1]]
                    self.ival = ins.args[2]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)  
                        
        elif ins.instr == 'mult': 
            if len(ins.args) == 2:
                self.gen = [Register("$hi"),Register("$lo")]
                self.need = [ins.args[0], ins.args[1]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)   
                      
        elif ins.instr == 'multu':
            if len(ins.args) == 2:
                self.gen = [Register("$hi"),Register("$lo")]
                self.need = [ins.args[0], ins.args[1]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)   
                        
        elif ins.instr == 'div':  
            if len(ins.args) == 2:
                self.gen = [Register("$hi"),Register("$lo")]
                self.need = [ins.args[0], ins.args[1]]
            elif len(ins.args) == 3:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1], ins.args[2]]                
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)   
                        
        elif ins.instr == 'divu': 
            if len(ins.args) == 2:
                self.gen = [Register("$hi"),Register("$lo")]
                self.need = [ins.args[0], ins.args[1]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)   
                        
        elif ins.instr == 'and': 
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                if self.is_reg(ins.args[2]):
                    self.need = [ins.args[1], ins.args[2]]
                else: 
                    self.need = [ins.args[1]]
                    self.ival = ins.args[2]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)  
                         
        elif ins.instr == 'andi': 
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1]]
                self.ival = ins.args[2]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)           
                
        elif ins.instr == 'or':   
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                if self.is_reg(ins.args[2]):
                    self.need = [ins.args[1], ins.args[2]]
                else: 
                    self.need = [ins.args[1]]
                    self.ival = ins.args[2]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)  
                        
        elif ins.instr == 'ori':  
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1]]
                self.ival = ins.args[2]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)           
                
        elif ins.instr == 'xor':  
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                if self.is_reg(ins.args[2]):
                    self.need = [ins.args[1], ins.args[2]]
                else: 
                    self.need = [ins.args[1]]
                    self.ival = ins.args[2]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr) 
                         
        elif ins.instr == 'xori': 
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1]]
                self.ival = ins.args[2]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)           
                
        elif ins.instr == 'nor':  
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                if self.is_reg(ins.args[2]):
                    self.need = [ins.args[1], ins.args[2]]
                else: 
                    self.need = [ins.args[1]]
                    self.ival = ins.args[2]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr) 
                                
        elif ins.instr == 'sll':  
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1]]
                self.ival = ins.args[2]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)  
                        
        elif ins.instr == 'sllv': 
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1]]
                self.ival = ins.args[2]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)  
                        
        elif ins.instr == 'srl':  
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1]]
                self.ival = ins.args[2]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)  
                        
        elif ins.instr == 'srlv': 
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1]]
                self.ival = ins.args[2]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)  
                        
        elif ins.instr == 'sra':  
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1]]
                self.ival = ins.args[2]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)  
                        
        elif ins.instr == 'srav': 
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1]]
                self.ival = ins.args[2]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)  
                        
        elif ins.instr == 'slt':  
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                if self.is_reg(ins.args[2]):
                    self.need = [ins.args[1], ins.args[2]]
                else: 
                    self.need = [ins.args[1]]
                    self.ival = ins.args[2]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)  
                        
        elif ins.instr == 'slti': 
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1]]
                self.ival = ins.args[2]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)           
                
        elif ins.instr == 'sltu':  
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                if self.is_reg(ins.args[2]):
                    self.need = [ins.args[1], ins.args[2]]
                else: 
                    self.need = [ins.args[1]]
                    self.ival = ins.args[2]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)        
                  
        elif ins.instr == 'sltiu':
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1]]
                self.ival = ins.args[2]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)           
   

    def parse_float(self,ins):
        """
        Parses the float type instructions.
        """
        if ins.instr == 'add.s':   
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1], ins.args[2]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)  
                        
        elif ins.instr == 'add.d':   
            if len(ins.args) == 3:
                self.gen = self.double_reg(ins.args[0])
                self.need = self.double_reg(ins.args[1]) + self.double_reg(ins.args[2])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                        
        elif ins.instr == 'sub.s':   
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1], ins.args[2]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                        
        elif ins.instr == 'sub.d':  
            if len(ins.args) == 3:
                self.gen = self.double_reg(ins.args[0])
                self.need = self.double_reg(ins.args[1]) + self.double_reg(ins.args[2])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                        
        elif ins.instr == 'mul.s':  
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1], ins.args[2]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                        
        elif ins.instr == 'mul.d':  
            if len(ins.args) == 3:
                self.gen = self.double_reg(ins.args[0])
                self.need = self.double_reg(ins.args[1]) + self.double_reg(ins.args[2])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                        
        elif ins.instr == 'div.s':  
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1], ins.args[2]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                        
        elif ins.instr == 'div.d': 
            if len(ins.args) == 3:
                self.gen = self.double_reg(ins.args[0])
                self.need = self.double_reg(ins.args[1]) + self.double_reg(ins.args[2])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                         
        elif ins.instr == 'abs.s':  
            if len(ins.args) == 2:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                                 
        elif ins.instr == 'abs.d':  
            if len(ins.args) == 2:
                self.gen = self.double_reg(ins.args[0])
                self.need = self.double_reg(ins.args[1])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                                      
        elif ins.instr == 'neg.s':  
            if len(ins.args) == 2:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                                      
        elif ins.instr == 'neg.d':  
            if len(ins.args) == 2:
                self.gen = self.double_reg(ins.args[0])
                self.need = self.double_reg(ins.args[1])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                                      
        elif ins.instr == 'sqrt.s': 
            if len(ins.args) == 2:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                                      
        elif ins.instr == 'sqrt.d': 
            if len(ins.args) == 2:
                self.gen = self.double_reg(ins.args[0])
                self.need = self.double_reg(ins.args[1])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                                      
        elif ins.instr == 'cvt':    
            if len(ins.args) == 2:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                                      
        elif ins.instr == 'cvt.d.w':
            if len(ins.args) == 2:
                self.gen = self.double_reg(ins.args[0])
                self.need = [ins.args[1]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                                      
        elif ins.instr == 'cvt.s.d':
            if len(ins.args) == 2:
                self.gen = [ins.args[0]]
                self.need = self.double_reg(ins.args[1])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                                      
        elif ins.instr == 'cvt.d.s':
            if len(ins.args) == 2:
                self.gen = self.double_reg(ins.args[0])
                self.need = [ins.args[1]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                                      
        elif ins.instr == 'cvt.s.w':
            if len(ins.args) == 2:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                                      
        elif ins.instr == 'cvt.w.s':
            if len(ins.args) == 2:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                                      
        elif ins.instr == 'cvt.w.d':
            if len(ins.args) == 2:
                self.gen = [ins.args[0]]
                self.need = self.double_reg(ins.args[1])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                                      
        elif ins.instr == 'c.eq.s': 
            if len(ins.args) == 2:
                self.gen = [Register("$fcc")]
                self.need = [ins.args[0],ins.args[1]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                                      
        elif ins.instr == 'c.eq.d': 
            if len(ins.args) == 2:
                self.gen = [Register("$fcc")]
                self.need = self.double_reg(ins.args[0]) + self.double_reg(ins.args[1])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                        
        elif ins.instr == 'c.lt.s': 
            if len(ins.args) == 2:
                self.gen = [Register("$fcc")]
                self.need = [ins.args[0],ins.args[1]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                         
        elif ins.instr == 'c.lt.d': 
            if len(ins.args) == 2:
                self.gen = [Register("$fcc")]
                self.need = self.double_reg(ins.args[0]) + self.double_reg(ins.args[1])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                         
        elif ins.instr == 'c.le.s': 
            if len(ins.args) == 2:
                self.gen = [Register("$fcc")]
                self.need = [ins.args[0],ins.args[1]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                         
        elif ins.instr == 'c.le.d': 
            if len(ins.args) == 2:
                self.gen = [Register("$fcc")]
                self.need = self.double_reg(ins.args[0]) + self.double_reg(ins.args[1])
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                         
        elif ins.instr == 'trunc.l.d':
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                self.need = self.double_reg(ins.args[1]) + [ins.args[2]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                         
        elif ins.instr == 'trunc.l.s':
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1],ins.args[2]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                        
        elif ins.instr == 'trunc.w.d':
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                self.need = self.double_reg(ins.args[1]) + [ins.args[2]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
        
        elif ins.instr == 'trunc.w.s':
            if len(ins.args) == 3:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1],ins.args[2]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)        
            

    def parse_misc(self,ins):
        """
        Parses the misc type instructions.
        """
        if ins.instr == 'nop':
            if len(ins.args) != 0:
                raise Exception("Invalid number of args for ins: ", ins.instr)
        elif ins.instr == 'syscall':
            if len(ins.args) != 0:
                raise Exception("Invalid number of args for ins: ", ins.instr)
        elif ins.instr == 'break':
            if len(ins.args) != 0:
                raise Exception("Invalid number of args for ins: ", ins.instr)
        elif ins.instr == 'mflo': 
            if len(ins.args) == 1:
                self.gen = [ins.args[0]]
                self.need = [Register("$lo")]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                
        elif ins.instr == 'mtlo':  
            if len(ins.args) == 1:
                self.gen = [Register("$lo")]
                self.need = [ins.args[0]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                           
        elif ins.instr == 'mfhi':   
            if len(ins.args) == 1:
                self.gen = [ins.args[0]]
                self.need = [Register("$hi")]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr) 
                         
        elif ins.instr == 'mthi':     
            if len(ins.args) == 1:
                self.gen = [Register("$hi")]
                self.need = [ins.args[0]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                          
        elif ins.instr == 'mtc1':    
            if len(ins.args) == 2:
                self.gen = [ins.args[1]]
                self.need = [ins.args[0]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)  
                       
        elif ins.instr == 'mfc1':  
            if len(ins.args) == 2:
                self.gen = [ins.args[0]]
                self.need = [ins.args[1]]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr) 
                           
        elif ins.instr == 'la':   
            if len(ins.args) == 2:
                self.gen = [ins.args[0]]
                self.ival = ins.args[1]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)
                            
        elif ins.instr == 'lui':        
            if len(ins.args) == 2:
                self.gen = [ins.args[0]]
                self.ival = ins.args[1]
            else:
                raise Exception("Invalid number of args for ins: ", ins.instr)        

    def parse_unknown(self,ins):
        """
        As we scanned all files were we will run benchmarks on, we will not
        encounter any unknown instructions for this assignment. This function
        is for later.
        """
        raise Exception("Unknown instruction type: ", ins.instr)
        
    def double_reg(self, reg):
        """
        Return two registers in a list: the one that is given as an argument
        and the one that comes after it (numrical).
        This is for float operations with double precision.
        """
        global numreg
        if type(reg) != Register:
            raise Exception("Not a register object")
        g = re.match(numreg, reg.expr)
        return [reg, Register(g.group(1) + str(int(g.group(2)) + 1))]
        
    def is_reg(self, val):
        return type(val) == Register 

def main():
    # test code
    from asmyacc import parser

    flat = []
    for line in open('../benchmarks/whet.s', 'r').readlines():
        if not line.strip(): continue
        flat.append(parser.parse(line))
        
    for inst in flat:
        if type(inst)==Instr:
            try:
                Instruction(inst)
            except Exception as e:
                print inst.instr, inst.args
                raise e
            
if __name__ == '__main__':
    main()
    pass
\end{lstlisting}

\newpage
\section{peephole.py}
\lstinputlisting{../src/peephole.py}

\newpage
\section{ranker.py}
\lstinputlisting{../src/ranker.py}

\newpage
\section{test\_block\_optimise.py}
%\lstinputlisting{../src/test_block_optimise.py}
\begin{lstlisting}
#! /usr/bin/env python
import unittest
import block_optimise
import ir
import cfg


class TestBlockOptimisers(unittest.TestCase):
    """ unittests for the block_optimise module  """


    def setUp(self):
        pass


    def tearDown(self):
        pass


#    def test_algebra(self):
#        dest1 = ir.Register('$dest1')
#        dest2 = ir.Register('$dest2')
#        divdest1 = ir.Register('divdest1')
#        instrs = [ir.Instr('li', [dest1, 1634563464])]
#        instrs.append(ir.Instr('filler', ['dest',1634563464,64]))
#        instrs.append(ir.Instr('li', [dest2, 64]))
#        instrs.append(ir.Instr('filler', ['dest',1634563464,64]))
#        instrs.append(ir.Instr('div.d', [divdest1,dest1,dest2]))
#        instrs.append(ir.Instr('filler', ['dest',1634563464,64]))
#        block = cfg.BasicBlock(instrs)
#        bop = block_optimise.AlgebraicTransformations(block = block)
#        bop.optimise()
#        expected = str(ir.Instr('sra', [divdest1, 1634563464, 6.0]))
#        result = str(block[4])
#        #TODO: map assertion to list of (expected,result)
#        self.assertTrue(result == expected)


    def test_const_fold_addu(self):
        dest1 = ir.Register('$dest1')
        dest2 = ir.Register('$dest2')
        dest3 = ir.Register('$dest3')
        adest1 = ir.Register('$adest1')
        adest2 = ir.Register('$adest2')
        instrs = [ir.Instr('filler', ['dest',1634563464,64])]
        instrs.append(ir.Instr('li', [dest1, 0x0001]))
        instrs.append(ir.Instr('filler', ['dest',1634563464,64]))
        instrs.append(ir.Instr('li', [dest2, 0x0002]))
        instrs.append(ir.Instr('filler', ['dest',1634563464,64]))
        instrs.append(ir.Instr('addu', [adest1,dest1,dest2]))
        instrs.append(ir.Instr('li', [dest3, 0x0003]))
        instrs.append(ir.Instr('filler', ['dest',1634563464,64]))
        instrs.append(ir.Instr('addu', [adest2,adest1,dest3]))
        instrs.append(ir.Instr('filler', ['dest',1634563464,64]))
        block = cfg.BasicBlock(instrs)
        bop = block_optimise.ConstantFold(block = block)
        bop.optimise()
        expected = str(ir.Instr('li', [adest2, '0x6']))
        result = str(block[8])
        self.assertTrue(result == expected)


    def test_copyprop_move(self):
        copy1 = ir.Register('$copy1')
        orig1 = ir.Register('$orig11')
        instrs = [ir.Instr('filler', ['dest',1634563464,64])]
        instrs.append(ir.Instr('move', [copy1, orig1]))
        instrs.append(ir.Instr('filler', ['dest',1634563464,64]))
        instrs.append(ir.Instr('addu', ['$adest1',copy1,'somereg']))
        instrs.append(ir.Instr('filler', ['dest',1634563464,64]))
        instrs.append(ir.Instr('addu', [copy1,'somereg',copy1]))
        instrs.append(ir.Instr('filler', ['dest',1634563464,64]))
        instrs.append(ir.Instr('addu', ['$adest2',copy1,'somereg']))
        block = cfg.BasicBlock(instrs)
        bop = block_optimise.CopyPropagation(block = block)
        bop.optimise()
        expected1 = str(ir.Instr('addu', ['$adest1', orig1, 'somereg']))
        result1 = str(block[3])
        expected2 = str(ir.Instr('addu', [copy1, 'somereg', orig1]))
        result2 = str(block[5])
        expected3 = str(ir.Instr('addu', ['$adest2', copy1, 'somereg']))
        result3 = str(block[7])
        self.assertTrue(result1 == expected1)
        self.assertTrue(result2 == expected2)
        self.assertTrue(result3 == expected3)


    def test_dead_code(self):
        reg1 = ir.Register('$1')
        reg2 = ir.Register('$2')
        reg3 = ir.Register('$3')
        reg4 = ir.Register('$4')
        reg5 = ir.Register('$5')
        sp = ir.Register('$sp')
        dp = ir.Register('$dp')
        r31 = ir.Register('$31')
        offsetadd1 = ir.Register('20($sp)')
        offsetadd2 = ir.Register('16($sp)')
        instrs = [ir.Instr('filler', ['$filler',1634563464,64])]
        instrs.append(ir.Instr('addu', [reg1,reg2,reg3]))
        instrs.append(ir.Instr('filler2', ['dest',9999,64]))
        instrs.append(ir.Instr('sll', [reg3, reg4, 10]))
        instrs.append(ir.Instr('filler3', ['dest',9999,64]))
        instrs.append(ir.Instr('lw', [reg3, '0(dp)']))
        instrs.append(ir.Instr('filler4', ['dest',9999,64]))
        instrs.append(ir.Instr('addu', [reg1,reg2,reg4]))
        instrs.append(ir.Instr('filler5', ['dest',9999,64]))
        instrs.append(ir.Instr('addu', [reg3,reg1,reg2]))
        instrs.append(ir.Instr('filler6', ['dest',9999,64]))
        instrs.append(ir.Instr('div', [reg1,reg2,reg4]))
        instrs.append(ir.Instr('move', [sp,dp]))
        instrs.append(ir.Instr('lw', [r31, offsetadd1]))
        instrs.append(ir.Instr('lw', [dp, offsetadd2]))
        instrs.append(ir.Instr('addu', [sp,dp,24]))
        block = cfg.BasicBlock(instrs)
        bop = block_optimise.DeadCode(block = block)
        bop.optimise()
        exp_instrs = [ir.Instr('filler', ['$filler',1634563464,64])]
        exp_instrs.append(ir.Instr('filler2', ['dest',9999,64]))
        exp_instrs.append(ir.Instr('filler3', ['dest',9999,64]))
        exp_instrs.append(ir.Instr('filler4', ['dest',9999,64]))
        exp_instrs.append(ir.Instr('addu', [reg1,reg2,reg4]))
        exp_instrs.append(ir.Instr('filler5', ['dest',9999,64]))
        exp_instrs.append(ir.Instr('addu', [reg3,reg1,reg2]))
        exp_instrs.append(ir.Instr('filler6', ['dest',9999,64]))
        exp_instrs.append(ir.Instr('div', [reg1,reg2,reg4]))
        exp_instrs.append(ir.Instr('move', [sp,dp]))
        exp_instrs.append(ir.Instr('lw', [r31, offsetadd1]))
        exp_instrs.append(ir.Instr('lw', [dp, offsetadd2]))
        exp_instrs.append(ir.Instr('addu', [sp,dp,24]))
        for i in xrange(len(block)):
            self.assertTrue(str(block[i]) == str(exp_instrs[i]))



if __name__ == '__main__':
    unittest.main()
\end{lstlisting}


\newpage
\section{uic.py}
\lstinputlisting{../src/uic.py}

